#!/bin/bash

# frc -- Frequently Run Commands

# inspired by https://github.com/pvolok/mprocs, which is a damn fine tool
# which you should definitely try out

# however, after getting used to it, I found myself really missing it on a
# couple of machines where there are policies that dictate what is allowed and
# what is not (don't ask, but this is not uncommon)

# because of that, and partly as a challenge, I decided to do this in shell,
# using fzf for the UI and tmux itself for the windowing

# upsides:
#   1.  use my own tmux shortcuts (muscle memory!) to navigate panes, kill
#       programs and so on

# downsides:
#   1.  live/dead status does not automatically update -- you have to hit
#       ctrl-r (see below)
#   2.  WARNING: DO NOT USE "tmux kill-pane" or similar commands, or any tmux
#       shortcut that runs those commands!
#   3.  I only need to run it *once*, from $HOME, so there's only one rc file
#       in a fixed location; you may need more than that

# usage:
#   -   create ~/.config/frc that has lines like this:
#               w0      wg-quick down wg0
#               w1      wg-quick up wg0
#               phs     nmcli dev wifi connect xk3phs
#               # phs == phone hotspot
#               *hwf    nmcli dev wifi connect homewifi
#               save    cd ~/work; rclone sync -v . workOneDrive:laptop-work
#       -   note: these are just some silly examples I made up; they're not
#           the ones I actually have in my rc file :)
#   -   once you have created the file, just run "frc" without arguments
#       -   (all invocations *with* arguments are "internal use only")

# notes on the rc file:
#   -   the format is "<name> <command> <args>"; NO LEADING SPACES PLEASE!
#   -   the "name" is a simple word that is shown by fzf which reminds you
#       what command it runs
#   -   the "command + args" is treated as a single string and run by "tmux
#       splitw", so you can include "cd" and such commands in it if you need
#       to run something from a different directory
#   -   a "*" in column one marks a command that will auto-start when you run frc
#   -   a "#" in column 1 marks a comment line
#   -   ~/.config/frc is the one you edit and is permanent.  At runtime,
#       however, all non-comment lines from this get copied to ~/.cache/frc;
#       as you add and remove commands this is the file that gets updated.
#       It gets overwritten every time you start frc

# the display is a typical fzf display on the left pane, and the individual
# target panes on the right, laid out vertically

# keys:
#   -   "enter" on a line to start it if it is not already running
#   -   ctrl-d to kill a pane and delete it from the list
#   -   ctrl-a to add a new command
#   -   ctrl-r to refresh the "live/dead" status
#       -   (marked by a "*" for programs that are running)
#   -   ctrl-e to "vimdiff" the permanent and running rc files; note that this
#       does not reload anything -- it just lets you update the permanent file
#       conveniently
#   -   ctrl-c to kill frc and all the panes it created, leaving only pane 0

# what mprocs has extra which I don't need (but you might)
# - cwd, env
# - array of words as command instead of just a single string passed to shell
# - kill/force kill (I use tmux shortcuts to go to the pane and kill it)
# - focus/toggle (I use tmux shortcuts)

# ----------------------------------------------------------------------

# User servicable parts
RC=$HOME/.config/frc
PERC=80             # view window takes 80% of the window

# ----------------------------------------------------------------------

[[ -n $TMUX ]] || { echo >&2 must run inside a tmux window; exit 1; }

ME="$0"
TTY=`tty`
unset FZF_DEFAULT_OPTS

[[ -z $1 ]] && {
    # no arguments means we're starting
    set -- _START
    sed -e 's/  */ /' < $RC | grep -v '^#' > ~/.cache/frc
}
RC=$HOME/.cache/frc
# this frc file is the "running" file described in comments earlier

# ----------------------------------------------------------------------

_start() {
    i=0
    while read name cmd
    do
        start=0
        if [[ $name =~ ^\* ]]; then
            start=1
            name=${name:1}
        fi
        if [[ $i == 0 ]]; then
            [[ $start == 1 ]] && tmux splitw -h -p $PERC "$cmd"
            [[ $start == 1 ]] || tmux splitw -h -p $PERC "sleep 1; echo; echo 'hit enter to run: $cmd'"
            tmux set -p remain-on-exit on
            tmux selectp -t 0
        else
            tmux selectp -t $i
            [[ $start == 1 ]] && tmux splitw "$cmd"
            [[ $start == 1 ]] || tmux splitw "sleep 1; echo; echo 'hit enter to run: $cmd'"
            tmux set -p remain-on-exit on
            tmux selectp -t 0
        fi
        (( i++ ))
    done < $RC

    # cut -f1 -d' ' < $RC | fzf --layout=reverse --no-sort \
    < $RC fzf --nth 1 --with-nth 1 --layout=reverse --no-sort \
        --bind "down:down+execute($ME > $TTY 2>&1 view  {n})+reload(cat $RC)" \
        --bind     "up:up+execute($ME > $TTY 2>&1 view  {n})+reload(cat $RC)" \
        --bind     "enter:execute($ME > $TTY 2>&1 enter {n})+reload(cat $RC)" \
        --bind    "ctrl-d:execute($ME > $TTY 2>&1 del   {n})+reload(cat $RC)" \
        --bind    "ctrl-a:execute($ME > $TTY 2>&1 add      )+reload(cat $RC)" \
        --bind    "ctrl-r:execute($ME > $TTY 2>&1 lds      )+reload(cat $RC)" \
        --bind    "ctrl-e:execute(gvimdiff ~/.config/frc ~/.cache/frc)" \
        --bind    "ctrl-c:execute(tmux killp -a -t 0)+abort" \
        --preview "echo {}|perl -pe 's/^\S+\s+//'" \
        --preview-window "down" \
        --info=inline \
        --header "^d: delete"$'\n'"^a: add"$'\n'"^r: update live/dead status"

}

view() {
    pane=$1; (( pane++ ))   # because fzf returns 0-based line number
    tmux resizep -t $pane -y 9999

    # this still shows one line of all the other panes but meh...  I can
    # always use tmux shortcuts to do a full zoom in/out if he wants

    # optionally uncomment, but screen looks glitchy so I don't use it:
    # lds           # update live/dead status for all
    # lds_1 $pane   # update live/dead status for just this pane
}

enter() {
    pane=$1; (( pane++ ))   # because fzf returns 0-based line number
    cmd="$(cat $RC | sed -n -e ${pane}p | cut -f2- -d' ')"
    tmux respawnp -t $pane "$ME > $TTY 2>&1 showcmd $pane; $cmd"
    lds_up $pane "*"
}

showcmd() {
    pane=$1;    # this one is called with a 1-based line number, watch out!
    printf "\n+ %s\n\n" "$(cat $RC | sed -n -e ${pane}p | cut -f2- -d' ')" >&2
}

del() {
    pane=$1; (( pane++ ))   # because fzf returns 0-based line number
    tmux killp -t $pane
    sed -i -e ${pane}d $RC
}

add() {
    pane=`wc -l < $RC`                  # last pane
    tmux selectp -t 0
    echo -n >&2 "name: "
    read name
    echo -n >&2 "command: "
    read cmd
    printf "*%s %s\n" "$name" "$cmd" >> $RC

    # notify-send "last pane=$pane"
    tmux selectp -t $pane
    tmux splitw "$cmd"
    tmux set -p remain-on-exit on
    tmux selectp -t 0
}

lds() {
    # update "live" or "dead" status of all panes
    seq `wc -l < $RC` | while read n
    do
        lds_1 $n
    done
}

lds_1() {
    read pd <<< $(tmux display -p -t $1 "#{pane_dead}")
    [[ $pd == 0 ]] && lds_up $1 "*"
    [[ $pd == 1 ]] && lds_up $1 ""
}

lds_up() {
    pane=$1
    prefix="$2"
    perl -i -pe "s/^\*?/$prefix/ if \$. == $pane" $RC
}

case $1 in
    _START )
        _start
        ;;
    view )
        view $2
        ;;
    enter )
        enter $2
        ;;
    showcmd )
        showcmd $2
        ;;
    del )
        del $2
        ;;
    add )
        add
        ;;
    lds )
        lds
        ;;
    * )
        echo COMMAND UNKNOWN >&2
        ;;
esac

