#!/usr/bin/perl
use warnings;
use strict;
use 5.10.0;

# usage:
#   dirdups dir1 dir2 | (cd some-empty-directory; dirdups)
#   cd some-empty-directory
#   tlsh4 -xref -r . -T 100 | mlr -t -N put '$c=strlen($1); $d=strlen($2)' then sort -nr c,d then cut -x -f c,d

# unfortunately this means you need to install 3 packages:
#   hashdeep (some distros have it as md5deep)
#   miller
#   tlsh (ubuntu has it as tlsh-tools)
# if you don't find them in your distro, URLs are:
#   https://github.com/jessek/hashdeep
#   https://github.com/johnkerl/miller
#   https://github.com/trendmicro/tlsh

# The program takes the output of md5deep and creates *files* for each
# directory.  For a directory called a/b it would create a file called a__b
# which contains *just the hashes (sorted)* of every file within a/b (to any
# depth, not just immediate).  This becomes a kind of "signature" for that
# directory.  These files are placed in an empty directory (see "Usage"
# comment at the top), then tlsh goes to work and decides how "far" these
# files are from each other, with a threshold of 100 (0 is a perfect match).
# Finally, miller sorts them in descending order of "length of filename" which
# means a/b/c will sort before a/b, thus the highest level folders with the
# best match will go to the end.

use Data::Dumper;

no strict 'refs';
use FileCache;

# ----------------------------------------------------------------------

if ( -t 0 and @ARGV ) {
    my @dirs = @ARGV; @ARGV = ();
    $ENV{LANG}="C";
    open(STDOUT, "|-", "sort");
    system(qw(md5deep -elr -of), @dirs);
    close(STDOUT);

    exit;
}

# check if we are in an empty directory
empty_or_die();

while (<>) {
    chomp;
    my ($hash, $file) = split ' ', $_, 2;
    while ($file =~ s(/[^/]+$)()) {
        my $f = "ddh-$file"; $f =~ s(/)(__)g;
        cacheout $f;
        say $f $hash;
    }
}

system "tlsh -xref -r . -T 100 | mlr --t2p -N put '\$c=strlen(\$1); \$d=strlen(\$2)' then sort -nr c,d then cut -x -f c,d";

# ----------------------------------------------------------------------

sub empty_or_die {
    my $x = `ls -A | grep -c .`;
    chomp $x;
    die "$ENV{PWD} not empty" if $x;
}
