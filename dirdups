#!/usr/bin/perl
use warnings;
use strict;
use 5.10.0;

use Data::Dumper;

# find duplicate DIRECTORIES, not files

# TODO: output format may need some attention

# usage:
#   dirdups dir1 dir2 | dirdups
# the first run "collects" the hashes, the second "reports" the duplicates

# directories have to match in both filenames *and* file content.  If you want
# to match only filenames pass "-f" to the "reporting" run.  If you want to
# match only file content pass "-c".  Do not pass both; results are undefined.

# can also be used like this:
#   # first collect from multiple directories into one file
#   dirdups dir1 >  /tmp/dirdups.out
#   dirdups dir2 >> /tmp/dirdups.out        # note the ">>"
#   [...more such dirdups...]
#   # then run the reporting code on the combined output file
#   dirdups < /tmp/dirdups.out | vim -
# this can be done across machines also, but see warning #2 below

# WARNINGS

# 1. only pass directory names; results are undefined if you pass filenames
#    (especially filenames in the *current* directory)

# 2. you can run the "collect" separately on separate directories and
#    concatenate the outputs if you need to do it that way, BUT: all the top
#    level directory names need to be different!  On the same machine this is
#    not an issue but suppose you want to collect hashes on machine A, bring
#    the file over to machine B, collect hashes on machine B *for the same
#    directory*, then do the reporting on the combined output file, this will
#    fail.
#
#    current workarounds:
#    - manually edit the output file from machine A to prefix each path with "A/"
#    - or, just create a symlink on machine A (ln -sf my/dir A-my-dir) then
#      run dirdups on "A-my-dir/" (note the trailing slash)

my ($dno, $dco);    # duplicate names/content only
( $ARGV[0] || '') eq '-n' and shift and $dno++;
( $ARGV[0] || '') eq '-c' and shift and $dco++;

if (@ARGV) {
    exec("find " . join(" ", @ARGV) . " -type f -print0 | xargs -0 b3sum")
    # if HDD (not SSD), may be useful to add "--num-threads 1" to the b3sum command
}

my %dh;     # directory name => contents
my %hd;     # contents => directory name
my %seen;

$ENV{LANG} = "C";
@ARGV = ("sort -k2 |");
@ARGV = ("sort |") if $dco;

while (<>) {
    chomp;
    my ($h, $f) = split;
    while ($f =~ m(/)) {
        $f =~ s(/([^/]+$))();
        # we said "dh" is "directory name => contents", but the "contents"
        # could be both pathname *and* hash, only pathname, or only hash:
        if ($dco) {
            # only hash
            $dh{$f} .= "$h\n";
        } elsif ($dno) {
            # only pathname
            $dh{$f} .= "$1\n";
        } else {
            # both
            $dh{$f} .= "$h $1\n";
        }
    }
}

# now reverse %dh.  The "key" is now the "content" described above, and the
# "value" is a directory name.  But there are potentially many directories
# with the same content, so the value is an *array of all directory names*
# that have the same content
for my $d (keys %dh) {
    my $h = $dh{$d};
    push @{ $hd{$h} }, $d;
}

# linecount is a crude way of counting how many files (not directories, just
# files) are in a directory, by counting newlines in the output of b3sum
sub linecount {
    return $_[0] =~ tr /\n//;
}
filter_print($_) for grep { @{ $hd{$_} } > 1 } sort { linecount($b) <=> linecount($a) or $a cmp $b } keys %hd;
# ^^^^ 3 ^^^^                   ^^^^ 2 ^^^^                      ^^^^ 1 ^^^^
# 1.    take the keys of hd (i.e., the "content" in our parlance, and sort
#       them by linecount (i.e., number of files)
# 2.    eliminate the ones where the *value* (i.e., the array of directory
#       names that have this specific content) is a singleton (no duplicates!)
# 3.    finally, print each set of duplicates, but filtered (see below)

# filter_print basically says if "a/b" is printed, then any "a/b/ANYTHING"
# after that will not be printed
sub filter_print {
    my @d = grep { !seen($_) } sort @{ $hd{$_} };
    return unless @d;
    say "# " . linecount($dh{ $d[0] }) . " files";
    say join ("\n", @d);
    say "";
}

sub seen {
    my $x = shift;
    for my $k (keys %seen) {
        return 1 if index($x, $k) == 0;
    }
    $seen{$x}++;
    return 0;
}
